///////////////////////////////////////////////////////////////////////////
// switchAdapt_Preproc.cc
// switch adaptor or preprocessor 
//
// in case the adaptor is called ahead, mesh construction
// is to be handled differently
//
// also a datastructure has to be provided for the solution transfer
//
// J.Mueller/O.Sahni 2004-2007
///////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <fstream>
#include <string.h>
#include <math.h>
#include "phParAdapt.h"
#include "func.h"
#include "ccfunc.h"

#include "MeshSimInternal.h"
#ifdef SIM
#include "SimPartitionedMesh.h"
#include "SimAdvMeshing.h"
#include "SimMeshTools.h"
#endif
#ifdef FMDB
#include "myAttribute.h"
#include "pmZoltanCallbacks.h"
#include "phPartitionCallbacks.h"
#include "AOMD_cint.h"
#include "mAOMD.h"
#include "pmZoltanCallbacks.h"
#ifdef ENTITY_GROUP
#include "AOMD_EntGrp.h"
#include "mEntityGroup.h"
#include "BLUtil.h"
#endif
#endif
//#include "M_writeVTKFile.h"
#include "MeshSimAdapt.h"
#include "phReadWrite.h"
#include "attachData.h"
#if ( defined SIM_PARASOLID )
  #include "SimParasolidKrnl.h"
#elif ( defined PARASOLID )
    #include "modelerParasolid.h"
#elif ( defined DISCRETE )
  #include "SimDiscrete.h"
#endif

#ifdef FMDB
  using namespace AOMD;
#endif

extern "C" int procSize();

#ifdef __cplusplus
extern "C" {
#endif

extern int adaptFlag;
extern int timeStepNumber;
extern int rStart;
extern int multipleRestarts;
extern int strategy;
extern int ensa_dof;// number of field(=solution) variables
extern int nSolVars;
extern int nErrorVars;
extern double* wght;
extern double factor;
extern double hmax;
extern double hmin;
extern int adaptOption;
extern int numTotParts;
extern int numParts;
extern int preLBforAdaptivity;
extern double masterProcWgt;
extern int SolutionMigration;
extern int DisplacementMigration;
extern pMeshDataId phasta_solution;
extern char gname[256];
pProgress prog;
pMeshDataId migrate_solution;
int lstep;
extern time_t wtimePoints[32];
extern int isBLAdapt;

int
switchAdapt_Preproc(int argc, char *argv[]){

    // process command line arguments
    // procArgs overwrites geom.sms by the mesh directory name specified
    // fname:attribute file name ,mname mesh directory name 
    procArgs(argc, argv);

    assignGlobalVars();

    lstep = timeStepNumber;

    // model and mesh declaration
    pGModel model; 
    pParMesh pmesh;
    pMesh mesh;
    int ndof = nSolVars, poly = 1;

//    pNativeModel nModel; //This variable is not used Min Zhou
    pACase acase;
    char    fname[100];
    char    mname[100];
  // default attribute/mesh filename
    strcpy(fname, "geom.spj");

    if((adaptFlag && (strategy!=7 || strategy!=8))|| multipleRestarts ){
        strcpy(fname, "geomNOIC.spj");
    }

    strcpy(mname, "geom.sms");

    pAManager attmngr = AMAN_load(fname);  // - guess that this replaces AMAN_retrieve()
    
    if (attmngr == 0){
      if (PMU_rank() == 0){
	fprintf(stderr, "could not open attribute file %s\n", fname);
	exit(-1);
      }           
    }
    else{
      if (PMU_rank() == 0){
	printf("\n AMAN_load(fname) success\n");
      }
    }
    acase = AMAN_findCase(attmngr, "geom");
    if (acase == NULL){
      char* casename="geom";
      if ( ( acase = AMAN_findCase(attmngr, casename)) == NULL) {
	printf("[%d] Error: could not find attribute case %s\n",PMU_rank(),casename);
	exit (-1);
      }
      else{
	if(PMU_rank() == 0)
	  printf("\n AMAN_findCase success\n");
      }
    }
    // associate the attribute case with the model
#if  ( defined SIM_PARASOLID )
    printf("\n model file = %s\n", gname);
    pParasolidNativeModel pnModel;
    pnModel = ParasolidNM_createFromFile(gname,0);  	// create Parasolid native model from part file
    model = GM_createFromNativeModel(pnModel, prog);
    NM_release(pnModel);

#endif    
    AttCase_setModel  ( acase, model );   

    // associate the case with the model (case: e.g. set of BCs)
    AttCase_associate(acase, prog);

#ifdef PARALLEL

    if(PMU_rank()==0) {
      printf("\n");
      printf("Meshing    Library build ID : %s\n",SimMeshing_buildID());
      printf("PMesh      Library build ID : %s\n",SimPartitionedMesh_buildID());
      printf("MeshTools  Library build ID : %s\n",SimMeshTools_buildID());
      printf("AdvMeshing Library build ID: %s\n",SimAdvMeshing_buildID());
    }
    
    double tmptime;
    wtimePoints[0] = time(0);
#ifdef SIM
    pmesh = PM_load(mname,sthreadDefault,model,prog);
//  mesh = PM_mesh(pmesh, 0);
   mesh = M_load(mname, model, prog);
#endif
#ifdef FMDB
    if(numTotParts < PMU_size())
        cout<<"ERROR: numTotParts < nproc, only numTotParts>=nproc is supported \n";

    pmesh = MS_newMesh(model);
    vector<pParMesh> meshes;

    PM_load(pmesh,mname);
    mesh = pmesh;

    tmptime = time(0);
    if(PMU_rank()==0)
      cout<<"Time Usage of PM_load is: "<<tmptime-wtimePoints[0]<<"\n";	
 
#ifdef ENTITY_GROUP
    if(isBLAdapt){
      printf("Constructing BLs...\n");
      constructBLs(pmesh);

      M_categorizeBLEntities(pmesh);
      M_unifyBLInterfaceOnCB(pmesh);

      M_assignBLLevelsToAllBLEnts(pmesh);
    }
#endif
#endif

    if(SolutionMigration && !adaptFlag) //migrate solution from restart files
    {
        migrate_solution = MD_newMeshDataId("solution migration");
        ifstream numstart("numstart.dat");
        int stepnum;
        numstart>>stepnum;
        char solutionfile[64];
        sprintf(solutionfile,"restart.%d.%d", stepnum,PMU_rank()+1);
        double *sol, *disp;
        int ndisp = 0;
        readArrayFromFile(solutionfile,"solution", sol);
        if(DisplacementMigration)
        {
            readArrayFromFile(solutionfile,"displacement", disp); 
            ndisp = 3;
        } 

        int nshg = M_numVertices(mesh);
        double *SolTot = new double[(ndof+ndisp)*nshg];
        for(int inode=0;inode<nshg;inode++) {
            for(int idof=0;idof<ndof;idof++)
                SolTot[inode*(ndisp+ndof)+idof] = sol[inode*ndof+idof];
            for(int idof=0;idof<ndisp;idof++)
                SolTot[inode*(ndisp+ndof)+ndof+idof] = disp[inode*ndisp+idof];
        }       
        
        attachArray(SolTot, mesh, migrate_solution,ndof+ndisp, poly);
        delete[] sol;
        delete[] SolTot;
        if(DisplacementMigration)
            delete[] disp;

        numstart.close();        
//        M_writeVTKFile(mesh, "InitialErrors", migrate_solution, ndof);
//        M_writeVTKFile(mesh, "InitialSolution", migrate_solution, ndof);
    }

#ifdef FMDB
    meshes.push_back(pmesh);
    
    if(numTotParts>PMU_size()&&!adaptFlag){ //multiparts per proc
        numParts = numTotParts/PMU_size();
        int remainPart = numTotParts - numParts*PMU_size();
        if(PMU_rank()<remainPart)
            numParts++;
        PM_setMaxNumParts(numParts);        
        tmptime = time(0);
        if(SolutionMigration){
            int ndisp = 0;
            if(DisplacementMigration){
                ndisp = 3;
            }
            phPartitionCallbacks zlb(migrate_solution, ndof+ndisp);
    	    zlb.setLocalNumParts(numParts);
            M_loadbalance2(meshes,zlb);
        }
        else{
            AOMD::zoltanCB zlb;
            zlb.setLocalNumParts(numParts);
            M_loadbalance2(meshes, zlb);
        }
       if(PMU_rank()==0)
          cout<<"Time Usage of M_loadbalance2 is :"<<time(0)-tmptime<<"\n";
    }
    else 
        PM_setMaxNumParts(1);

    wtimePoints[1] = time(0);
    
    if(PM_verify  (  pmesh ,0,sthreadDefault,prog ) == 0){
      if (PMU_rank() == 0){
	printf("\nerror in adapt.cc: invalid parallel mesh read in\n");
      }
      SimPartitionedMesh_stop();
      exit(1);
    }
    
#endif
#endif
//to calculate minimum and maximum edge lengths

     EIter eit=M_edgeIter(mesh);
     pEdge edge;
     int numEdges = 0;
     double local_uniformSize = 0., local_len[2] = {1.0e10, 0.};
     while( edge=EIter_next(eit) ) {
        numEdges++;
        double len = sqrt(E_lengthSq(edge));
        local_uniformSize += len;
        if(len<local_len[0]) 
          local_len[0] = len;
          if(local_len[1]<len)
          local_len[1] = len;
      }
      EIter_delete(eit);
     printf("min & max edge length: %.16e %.16e\n",local_len[0],local_len[1]);

            //

    // use the adaptor first
    // created new mesh, new restart files
    // total number of DOFS defined here
    int nshgTot=0;
    if(adaptFlag){
        
#ifndef ibm
//        printf("\n[%2d] memory usage before mesh adaptation: %d (KB)\n",PMU_rank(),phParAdaptProcSize());
#endif
        // flags needed by the preprocessor
        // to directlty take the ICs from the restart files
        // reads files: ./restart.%d.%d
        rStart=1;
        nshgTot = adapt (pmesh,
                         mesh,
                         model,
                         timeStepNumber,
                         strategy,
                         factor,
                         // number of field(=solution) variables
                         ensa_dof,
                         // number of variables for error indicators (EI)
                         // (e.g., 5 for ybar & 10 for residual-based)
                         nErrorVars,
                         hmax,
                         hmin,
                         adaptOption);
#ifndef ibm
  //      printf("\n[%2d] memory usage after mesh adaptation: %d (KB)\n",PMU_rank(),phParAdaptProcSize());
#endif
#ifdef FMDB
        meshes.clear();
        meshes.push_back(pmesh);

        if(numTotParts>PMU_size()){ //multiparts per proc
            numParts = numTotParts/PMU_size();
            PM_setMaxNumParts(numParts);        
            int ndisp = 0;
            if(DisplacementMigration)
                ndisp = 3;
            phPartitionCallbacks zlb(phasta_solution, ndof+ndisp);
    	    zlb.setLocalNumParts(numParts);
            M_loadbalance2(meshes,zlb);
        }
#endif
    }

#ifdef SIM
    vector<pParMesh> meshes;
    meshes.push_back(pmesh);
#endif

    if(nErrorVars)
      delete [] wght; 

    // continue with the usual preprocessing
    mdb2phasta (fname,mname,model, meshes,nshgTot );
#ifndef ibm
    //printf("\n[%2d] memory usage after running preprocessor: %d (KB)\n",PMU_rank(),phParAdaptProcSize());
#endif

    AMAN_release(attmngr);
    MD_deleteMeshDataId(migrate_solution);
    /* Delete mesh */
    for(int ipart=0;ipart<numParts;ipart++)
        //Mesh need to be release here Min Zhou
//        M_release((pUnstructuredMesh) meshes[ipart]);

    /* Delete the model. */
        //Model need to be recleased here Min Zhou
//    GM_release(model);
    
    return 1;
    
}


#ifdef __cplusplus
}
#endif   
